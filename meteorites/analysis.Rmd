---
title: "Meteorites Weekend Homework"
author: "Lesley Duff"
date: "`r format(Sys.Date())`"
output:
  html_document:
    df_print: paged
subtitle: Analysis
---
# Meteorites Analysis

We have data from [NASA](https://www.nasa.gov/) which has information on 
meteorites that have been found up to the year 2013.

```{r}
library(testthat)
```

```{r}
source("cleaning.R") # brings in libraries assertr/janitor/tidyverse

# Read the cleaned data into R.
meteorite_data <- process_meteorite_landings_file("data/meteorite_landings.csv")
```
## Names and years for the 10 largest meteorites

```{r}
# Find the names and years found for the 10 largest meteorites in the data.
meteorite_data %>%
  slice_max(mass_g, n = 10) %>%
  select(name, year)
```
## Average mass of meteorites

```{r}
# Find the average mass of meteorites that were recorded falling, vs. those
# which were just found.
meteorite_data %>%
  group_by(fall) %>%
  summarise(avg_mass_g = mean(mass_g, na.rm = TRUE))
```

## Number of meteorites in each year, for every year since 2000.

```{r}
# Find the number of meteorites in each year, for every year since 2000.
meteorite_data %>%
  filter(year >= 2000) %>%
  group_by(year) %>%
  summarise(number_of_meteorites = n())
```

## Function get_meteorite_count()

```{r}
# Write a function called get_meteorite_count() that takes in two arguments:
#  a dataframe and a year, and returns the phrase "In (input_year), there were
# (number of meteorites that year) meteorites." IF there are 1 or more
# meteorites that year. If there are no meteorites in the year, return the
# phrase "As far as #we know, there were no meteorites that year".
get_meteorite_count <- function(dataframe, input_year) {
  output <- ""
  
  # Extract number_of_meteorites that year
  number_of_meteorites <- dataframe %>%
    filter(year == input_year) %>%
    summarise(number_of_meteorites = n()) %>%
    pull()

  if (number_of_meteorites >= 1) {
    output <- str_c(
      "In ", input_year, ", there were ", number_of_meteorites,
      " meteorites."
    )
  } else {
    output <- "As far as we know, there were no meteorites that year"
  }

  return(output)
}

# Year with count
count_meteorite <- get_meteorite_count(meteorite_data, 2009)
count_meteorite

# Year with no count
count_meteorite <- get_meteorite_count(meteorite_data, 2020)
count_meteorite

#count_meteorite <- get_meteorite_count(meteorite_data, NA)
#count_meteorite <- get_meteorite_count(meteorite_data, -1000)
```
### Test plans

#### How to test that function is working as expected 

```{r}
test_that("Years with meteorites return count", {
  expect_equal(get_meteorite_count(meteorite_data, 2009), 
               "In 2009, there were 103 meteorites.")
  expect_equal(get_meteorite_count(meteorite_data, 2013), 
               "In 2013, there were 2 meteorites.")
})

test_that("Years with no meteorites return no meteorites message", {
  expect_equal(get_meteorite_count(meteorite_data, 1584), 
               "As far as we know, there were no meteorites that year")
  expect_equal(get_meteorite_count(meteorite_data, 2020), 
               "As far as we know, there were no meteorites that year")
})
```

How the function could be improved.

1. The simple if statement means negative numbers are treated the same as zero.
Add an extra test explicitly for zero and indicate anything else is a negative 
number and an error.

```{r, error=TRUE}
test_that("Year cannot be negative", {
  expect_error(get_meteorite_count(meteorite_data, -2013))
})
```
2. There is no checking that year is in the future e.g. mistyping a year
```{r, error=TRUE}
test_that("Year is not in the future", {
  expect_error(get_meteorite_count(meteorite_data, 20012))
})
```

### Unit test

Test to check whether non-numeric inputs 
(character and logical) for the year argument return an error.

```{r, error=TRUE}
test_that("non-numeric inputs for the year argument return an error", {
  expect_error(get_meteorite_count(meteorite_data, TRUE))
  expect_error(get_meteorite_count(meteorite_data, "2009"))
})
```

### refactor_get_meteorite_count

```{r}
refactor_get_meteorite_count <- function(dataframe, input_year){
  # Make sure input_year only takes in numeric input
  if (!is.numeric(input_year)){
    stop("Non-numeric year ðŸ˜¿")
  }
  # Make sure number is >= 0 
  if (input_year < 0){
    stop("Year cannot be a negative number ðŸ˜¿")
  }

  output <- ""
  
  # Extract number_of_meteorites that year
  number_of_meteorites <- dataframe %>%
    filter(year == input_year) %>%
    summarise(number_of_meteorites = n()) %>%
    pull()

  output <- case_when(
  # Return a count if there is a positive number of landing
  number_of_meteorites >= 1 ~
    str_c(
     "In ", input_year, ", there were ", number_of_meteorites,
      " meteorites."
    ),
  # Explicitly test for zero
  number_of_meteorites == 0 ~ 
    "As far as we know, there were no meteorites that year",
  TRUE ~ "As far as we know, there were no meteorites that year")

  return(output)
}
```

```{r, error=TRUE}
# Test your function to make sure it now gives an error when you input a logical
# or character value as the year.
test_that("Non-numeric input returns an error", {
  expect_error(refactor_get_meteorite_count(meteorite_data, "year"))
  expect_error(refactor_get_meteorite_count(meteorite_data, TRUE))
})

# Check working as expected
test_that("Years with meteorites return count", {
  expect_equal(refactor_get_meteorite_count(meteorite_data, 2009), 
               "In 2009, there were 103 meteorites.")
  expect_equal(refactor_get_meteorite_count(meteorite_data, 2013), 
               "In 2013, there were 2 meteorites.")
})

test_that("Years with no meteorites return no meteorites message", {
  expect_equal(refactor_get_meteorite_count(meteorite_data, 1584), 
               "As far as we know, there were no meteorites that year")
})

# My own suggested improvements
# Error if negative number supplied
test_that("Year cannot be negative", {
  expect_error(refactor_get_meteorite_count(meteorite_data, -2013))
})



```

